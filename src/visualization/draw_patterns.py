#!/usr/bin/env python3
# Copyright 2017 Christian Henning
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
@title           :visualization/draw_patterns.py
@author          :ch
@contact         :christian@ini.ethz.ch
@created         :04/05/2017
@version         :1.0
@python_version  :3.5.2

Visualizing a PatternGeneration instance.

This module can be used to investigate the different patterns, generated by the
class PatternGeneration. To evaluate their quality the module computes and
plots several measures additional to the plotted pattern activation per neuron
for all classes.
"""

import configuration as config

import matplotlib.pyplot as plt
import matplotlib.patches as patches
import matplotlib.cm as cm
import matplotlib.colors as mcolors
import numpy as np
import os
import math

from util import lin_alg as la

import logging
logger = logging.getLogger(config.logging_name)

def draw_patterns(network, pattern):
    """Draw the pattern for each output class in a different plot. The
    activation per neuron is color coded. Only excitatory neurons are drawn, as
    the patterns are only going to influence those.

    Args:
        network: An instance of the class NetworkModel.
        pattern: An instance of the class PatternGeneration.

    Returns:
    """
    w = network.num_layers
    # Maximum number of neurons per layer.
    max_n = max([network.layer_size(i) for i in range(w)])

    # A scaling factor, to scale the whole plot to a higher resolution (outside
    # the box 0..1).
    # Do not change! Not implemented.
    scaling = 1.0

    # Width of a single layer.
    layer_width = 1./w * scaling
    # The maximum height a single neuron can demand.
    neuron_height = 1./max_n * scaling

    # Circle radius (radius of a single neuron).
    radius = 0.8 * min(layer_width, .5*neuron_height)

    num_plots = pattern.num_patterns
    plot_rows = int(math.floor(math.sqrt(num_plots)))
    plot_cols = int(math.ceil(math.sqrt(num_plots)))

    plt.close('all')
    fig, axes = plt.subplots(plot_rows,plot_cols)
    plt.suptitle('Pattern: %s' % config.pattern_type)
    fig.subplots_adjust(hspace=0.4)

    for i in range(num_plots):
        r = i // plot_cols
        c = i % plot_cols

        axes[r,c].set_title('Output class %d' % i)
        axes[r,c].get_xaxis().set_visible(False)
        axes[r,c].get_yaxis().set_visible(False)

    for i in range(num_plots, plot_rows*plot_cols):
        r = i // plot_cols
        c = i % plot_cols

        axes[r,c].set_axis_off()

    # Store position of each neuron (index: layer, neuron).
    positions = dict()

    ### Draw neurons of each layer.
    # The circle should be centered within a box of size layer_width x
    # neuron_height. Therefore, we need the offsets within this box.
    cox = layer_width / 2.
    coy = neuron_height / 2.

    cmap = cm.get_cmap('seismic')
    color = lambda x : cmap(x/2. + .5)

    for i in range(num_plots):
        r = i // plot_cols
        c = i % plot_cols
        ax = axes[r,c]

        x_offset = 0

        for l in range(w):
            nn = network.layer_size(l)

            y_offset = (scaling - nn * neuron_height) / 2.

            if l > 0:
                pat = pattern.get_pattern(l,i)
            else:
                pat = np.zeros(nn)

            for n in range(nn):
                ind = (l, n)
                positions[ind] = (x_offset+cox, y_offset+coy)
                ax.add_patch(patches.Circle(positions[ind], radius,
                                            facecolor=color(pat[n]),
                                            edgecolor='k'))

                y_offset += neuron_height

            x_offset += layer_width

    # Setup colorbar as legend.
    normalizer = mcolors.Normalize(vmin=-1, vmax=1)
    cbar = cm.ScalarMappable(norm=normalizer, cmap=cmap)
    cbar_values = np.linspace(-1,1,3)
    cbar.set_array(cbar_values)

    # Adjust figure, just that colorbar has enough space on the left.
    fig.subplots_adjust(right=0.8)
    cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.7])

    plt.colorbar(cbar, cax=cbar_ax)

    # Add textbox with additional information.
    fig.subplots_adjust(top=0.8)
    text_ax = fig.add_axes([0.0, 0.0, 1.0, 0.1])
    text_ax.get_xaxis().set_visible(False)
    text_ax.get_yaxis().set_visible(False)

    orth_msg = 'Orthogonality [layer = mean (std. dev.)]: '
    eucl_msg = 'Euclidean Distance [layer = mean (std. dev.)]: '
    spars_msg = 'Sparsity (rel. percentage) [layer = mean (std. dev.)]: '
    for l in range(1, network.num_layers-1):
        pat = pattern.get_pattern(l)
        m, sd = la.check_orthogonality(pat)
        orth_msg += '%d = %g (%g), ' % (l, m, sd)
        m, sd = la.check_euclidean_distances(pat)
        eucl_msg += '%d = %g (%g), ' % (l, m, sd)
        m, sd = la.evaluate_sparsity(pat)
        spars_msg += '%d = %g (%g), ' % (l, m, sd)

    msg = orth_msg + '\n' + eucl_msg + '\n' + spars_msg

    text_ax.text(0.5, 0.5, msg, horizontalalignment='center',
                 verticalalignment='center')

    # FIXME depends on the backend
    manager = plt.get_current_fig_manager()
    manager.resize(*manager.window.maxsize())

    if config.save_pattern_plot:
        # Check if directory of plot already exists.
        fn = config.patterns_plot_filename
        if not os.path.isdir(os.path.dirname(fn)):
            os.mkdir(os.path.dirname(fn))
        plt.savefig(fn, format='svg')

    if config.plot_patterns:
        plt.show()

if __name__ == '__main__':
    pass


